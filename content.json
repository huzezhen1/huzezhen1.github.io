[{"title":"使用nvm管理node版本","date":"2018-11-23T13:09:18.000Z","path":"2018/11/23/nvm/","text":"安装Node.js的最佳方式是使用nvm。 下载并安装nvm为了方便，我们在下载地址中选择 nvm-setup.zip，然后解压按照正常软件安装即可。 如果是 nvm-noinstall.zip 版本可以点击参考。 使用nvm来安装和管理node版本比如需要安装node8.9.1版本 1nvm install 8.9.1 没有意外情况下就帮你安装好node和npm，我们可以查看版本 1nvm list 切换到我们想要的node8.9.1版本 1nvm use 8.9.1 比如想删除node8.9.1版本 1nvm uninstall 8.9.1 其他情况当时安装时因为网速问题在自动安装npm时一直失败，后来设置到淘宝镜像服务器就解决了。 具体操作是在nvm安装文件夹中找到settings.txt，新增了配置，最终如下： 123456root: C:\\Users\\huzez\\AppData\\Roaming\\nvmpath: C:\\Program Files\\nodejsarch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/","comments":true,"tags":[{"name":"nvm","slug":"nvm","permalink":"//huzezhen.cn/tags/nvm/"}]},{"title":"Markdown常用语法","date":"2018-11-22T18:02:41.804Z","path":"2018/11/23/markdown-note/","text":"记录下Markdown的一些语法 标题语法 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表语法 无序列表 1234567- 无序列表1- 无序列表2- 无序列表3-----或-----* 无序列表1* 无序列表2* 无序列表3 有序列表 1231. 有序列表项目2. 有序列表项目3. 有序列表项目 多层列表 1234- 外层列表1 - 内层列表1 - 内层列表2- 外层列表2 效果 无序列表1 无序列表2 无序列表3 有序列表项目 有序列表项目 有序列表项目 外层列表1 内层列表1 内层列表2 外层列表2 引用语法 123&gt; 引用的文字 &gt; 引用的文字 &gt;&gt; 引用中的引用 效果 引用的文字引用的文字 引用中的引用 图片与链接语法 图片 1![名字](图片地址),如:[icon](http://a.com/a.jpg) 链接 1[名字](链接地址),如:[百度](https://www.baidu.com) 粗体与斜体语法 粗体 12**粗体** __粗体__ 斜体 12*斜体*_斜体_ 效果 粗体粗体斜体_斜体_ 表格语法12345| ABCD | EFGH | IJKL | | -----|:----:| ----:| | a | b | c | | d | e | f | | g | h | i | 效果 ABCD EFGH IGKL a b c d e f g h i 代码框语法 1`代码代码代码` 效果 代码代码代码 分割线语法 12---*** 效果 以上两条就是对应效果 编辑器 Mac平台 Mou Windows平台 MarkdownPad MarkPad Web端 Draftin 简书","comments":true,"tags":[{"name":"markdown","slug":"markdown","permalink":"//huzezhen.cn/tags/markdown/"}]},{"title":"关于vscode的一些记录","date":"2018-05-07T05:48:53.000Z","path":"2018/05/07/vscode-record/","text":"对vscode的相关记录 前言最近在试用vscode，先把大老婆sublime丢到一边，记录下vscode一些插件及用法，当作自己备忘。 sublime启动的速度还是无敌，不过有ssd情况下vscode给我的体验也很好，不像atom这个仿佛开挂的卡逼。 操作记录安装插件在最左侧的“扩展”中搜索并安装，简单方便，快捷键是ctrl + shift + x 打开用户设置在安装好插件后想对插件进行自定义设置 ctrl + shift + p， 然后搜索ouss（ 即open user settings） 或者 【文件】-&gt;【首选项】-&gt;【设置】 插件记录HTML Snippets实用且初级的HTML5代码片段以及提示 但是好像新版的vscode自带的emmet已经有这个功能 HTML CSS Support让HTML标签上写class， 智能提示当前项目所支持的样式 fileheaderctrl + shift + i， 可在头部插入注释， 包括作者信息， 需用户配置自己的名字等 比如我自己的设置： 1234// setting.json，在用户设置中\"fileheader.Author\": \"hu.zezhen\",\"fileheader.LastModifiedBy\": \"hu.zezhen\" jQuery Code Snippets编码的时候输入jq， 会有相关jQuery代码提示 不过觉得这样蛮傻的，不知道还有没有更友好点的提示 vscode - icon让vscode资源树目录加上图标 Path Intellisense自动补全路径，在输入路径时比较好用，比如输入img标签的src路径时 HTMLHintHTML代码检测 Project Manager多个项目之间快速切换 需要先ctrl + shift + p，搜索Project Manager然后选择Save Project 然后才会在左侧的project中看得到这个项目，然后可以保存多个之后就可以在里面切换 这一点sublime就方便多了，直接文件夹拖入左侧的Side Bar就行了 Atuo Rename Tag修改HTML标签，自动帮你完成尾部闭合标签的同步修改 GitLens丰富的git日志插件 打开有关联git远程仓库的文件夹时会在左侧中出现GitLens项 还能显示当前行的commit信息 Git Historygit log，会在标题页右侧有个按钮Git: View History Open HTML in Default BrowserHTML文件中，右键会显示“在浏览器中打开”，会使用默认浏览器打开当前文件 filesize装了之后会在左下角显示当前文件大小 Bracket Pair Colorizer让括号有独立颜色，便于区分，可查看安装页的详细配置，例如我自己的用户配置： 123\"bracketPairColorizer.forceIterationColorCycle\": true,\"bracketPairColorizer.forceUniqueOpeningColor\": true,\"bracketPairColorizer.showBracketsInGutter\": true vetur开发vue时必备，语法高亮、智能感知、Emmet等 VueHelpervue相关的snippet代码片段 Markdown Preview Enhanced预览markdown文件，右键选择Markdown Preview Import Cost会显示import引入的包的大小 Dark-Dracula这是一个主题，目前自己用的这个 vscode-background可以给编辑器加背景图片，详细配置也可查看安装页的说明，我这里的配置是： 1234567891011121314151617181920\"background.enabled\": true,\"background.useDefault\": false,\"background.customImages\": [ // 支持本地图片和https开头的图片 // 最多可分三栏，所以最多支持三张 \"https://xxx.com/cdn/ybmq.min.png\", \"https://xxx.com/cdn/ybmq.min.png\", \"https://xxx.com/cdn/ybmq.min.png\" ],\"background.style\": &#123; \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", \"z-index\": \"99999\", \"width\": \"100%\", \"height\": \"100%\", \"background-position\": \"100% 100%\", \"background-repeat\": \"no-repeat\", \"opacity\": 0.3&#125; 需要注意的是安装了这个插件，vscode会提示安装损坏，选择“不再提示”即可，作者自己在安装页也有解释。 Beautify格式化代码格式，可在用户配置中配置自己的风格，例如我这里配置了缩进为2个空格 1234\"beautify.config\": &#123; \"indent_size\": 2, \"indent_char\": \" \"&#125; Setting Sync上传配置 Shift + Alt + U 下载配置 Shift + Alt + D 同步vscode插件等设置用的，测试了给宿舍的电脑同步公司上的设置可用 详细配置可点击参考","comments":true,"tags":[{"name":"vscode","slug":"vscode","permalink":"//huzezhen.cn/tags/vscode/"}]},{"title":"JavaScript定时器","date":"2017-04-21T13:56:00.000Z","path":"2017/04/21/javascript-timer/","text":"主要探究setTimeout()、setInterval()的运行机制 如果你知道setTimeout(fn, 0)的作用，那可以不用点开本文 前言JavaScript的定时器主要是由setTimeout()和setInterval()组成 setTimeout()1setTimeout(fn|code, delay); 表示delay秒之后执行fn或者code，只执行一次 第一个参数可以是一个函数，也可以是一段代码字符串，因为内部是用eval来执行的，所以需要是字符串 第二个参数是指延迟多少毫秒后执行第一个参数，省略的话则表示0 其实后面还可以带其他参数，作为第一个参数（函数）的实参，但是IE9以下不支持，例如： 12345// 2秒后输出1// 但是一般没这么写，直接把实参写到函数体内不就好了setTimeout(function(a)&#123; console.log(a);&#125;, 2000, 1) 注意： 返回值是一个整数值，代表这个计时器，供给clearTimeout()来清除这个定时器 HTML5标准规定，setTimeout()的最短时间间隔是4毫秒 setTimeout()是挂在window对象下的，延迟之后的执行函数中的this，永远指向window setInterval()大概用法与setTimeout()一致，不过setInterval()表示的是每隔多久就会执行一次 需要注意的是，这次间隔时间是从上次执行开始就开始计算的，比如说，每100ms执行一次，但是执行过程需要5ms，也就是95ms之后就会执行第二次了 注意：HTML5标准规定，setInterval()的最短间隔时间是10毫秒 clearTimeout()、clearInterval()setTimeout()、setInterval()返回的是一个整数值，代表这个定时器，传入对应的clearTimeout()或clearInterval()则可清除对应的定时器 运行机制想要了解运行机制，首先得了解下JavaScript的Event Loop： JavaScript：彻底理解同步、异步和事件循环(Event Loop)并发模型与事件循环关于Event Loop JavaScript是单线程的，我们称这条单线程为主线程，所有同步任务（包括调用异步函数，但不包括执行异步任务、触发回调等操作）都在主线程上执行，形成一个执行栈 主线程之外，还存在一个任务队列（task queue，也有人叫做消息队列），只要异步任务有了运行结果，就在任务队列之中放置一个事件(消息，对应着回调函数) 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列（由于定时器的存在，所以会先判断是否到了执行时间），于是那些对应的异步任务就结束等待状态，进入执行栈，开始执行，主线程会不断重复这一操作，这过程就叫事件循环(Event Loop) 那么有上面的知识基础的话，我们应该清楚setTimeout()、setInterval()会将执行代码先放到异步任务（即移出本次的执行栈），然后在下一次事件循环时判断是否到了执行时间，是则执行，还没到则下次事件循环再判断，换句话说，也就是要等到本轮Event Loop的同步任务都执行完，才会判断是否开始执行 因此也无法保证一定会按照规定的时间执行，比如说本轮的某个同步任务执行完需要很久很久的时间 特别是对于setInterval()事件，它具有积累性，比如说： 12345678setInterval(function () &#123; console.log(2);&#125;, 1000);//下面执行完需要3秒(function () &#123; sleeping(3000); &#125;)(); 结果会是:下面的语句完成(需3秒)后连续输出三个2，然后再开始每隔1秒输出一个2，就是因为setInterval()具有累积效应 setTimeout(fn, 0)经常看到setTimeout(fn, 0)，可能很多人看到0会认为是立即执行，其实不然，通过上面运行机制的了解也应该知道不会立即执行 其实他最主要的作用是用来改变事件的执行顺序，比如： 1234567891011var input = document.getElementsByTagName('input[type=button]')[0];input.onclick = function A() &#123; setTimeout(function B() &#123; input.value +=' input'; &#125;, 0)&#125;;document.body.onclick = function C() &#123; input.value += ' body'&#125;; 当我们点击input时，触发的几个函数的执行顺序为：A -&gt; C -&gt; B 扩展关于正常任务与微任务 正常任务：下一轮Event Loop才会执行的任务，大概有这样的正常任务：setTimeout、setInterval、setImmediate、I/O、各种事件（比如鼠标单击事件）的回调函数微任务：本轮Event Loop的所有任务结束后执行，目前主要是：process.nextTick和Promise 简单例子加以理解： 12345678910111213console.log(1);setTimeout(function() &#123; console.log(2);&#125;, 0);Promise.resolve().then(function() &#123; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 执行结果为：先输出1 然后5 然后3 然后4 然后2解释：首先输出1，然后setTimeout(fn,0)是在本轮队列全部执行完后才执行，Promise的resolve是放在本轮队列的最后执行，但还是属于本轮，因此接下来是输出5，然后才是Promise的resolve，输出3，输出4，最后才是输出2 另一个经典例子： 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 执行结果为：输出2，3，5，4，1解释：setTimeout(fn,0)是在本轮队列执行完后才执行，Promise里面的函数直接执行，输出2，输出3，Promise的resolve则是放到本轮队列的最后，因此接下来执行5，然后才是执行resolve，即then里面的输出4，最后才是setTimeout的输出1","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"}]},{"title":"移动端手势的实现原理","date":"2017-04-15T12:15:00.000Z","path":"2017/04/15/mobile-gesture/","text":"探究下移动端上一些手势实现的思路 前言之前写过一篇介绍移动端触摸事件的文章，我们得知移动上几个原生的触摸事件：touchstart、touchmove、touchend、touchcancel，那怎么利用这些原生的事件来实现一些手势呢，本文主要就是介绍这些手势交互实现的一些思路 单指手势前提，整个事件定义一个中间状态status表示当前的触摸状态 轻触taptouchstart触发时，状态改为tap，若touchend时还是tap，则认为是tap 双击轻触doubletap触发tap事件时记录当前时间，下次触发tap事件时用当前时间与记录的时间进行对比，如果小于300ms则认为触发了doubletap 长按presstouchstart触发时设置一个500ms的setTimeout，500ms后仍然没有touchend触发则把状态改为press，等到touchend时检测到状态press则认为触发press 平移pantouchmove过程中检测状态是否是tap或者press，并且移动距离大于10px（自己规定）则认为是pan 关于移动距离的计算： 123var distanceX = touchEnd.clientX - touchStart.clientX, // touchmove的x坐标减去touchstart的x坐标var distanceY = touchEnd.clientY - touchStart.clientY, // touchmove的y坐标减去touchstart的y坐标var distance = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2)); // 利用勾股定理求值 轻拂flicktouchend时通过pan的移动距离和移动事件算出速度（X轴和Y轴的合速度），如果速度大于0.5且触摸过程时间小于100ms则认为是flick 关于合速度：将物体的速度分为x方向速度（水平速度）,和y方向速度（竖直速度）那么合速度就是&radic;(x2+y2)，即根号下x平方加y平方 多指手势这里只研究两个手指的触控，假设： touchstart时，两个手指的坐标点 A(x1, y1)、B(x2, y2)touchmove时，两个手指的坐标点 C(x3, y3)、D(x4, y4) 旋转rotate计算AB，CD线段与坐标轴的夹角，对角度相减即得到旋转角度 缩放scale计算AB线段长度和CD线段长度(勾股定理)，两条线段做比值就好 平移ranslate平移的话我们只计算A点到C点的x坐标变化量 扩展contains / compareDocumentPosition回想下两个手指同时触控的场景，有个问题不可避免，就是当两个手指作用在不同的DOM上面时该触发哪个节点的事件呢？ 我们规定取两个手指节点公有的最近父节点作为触发的节点，那么如何取这个公用的最近父节点呢？没错，我们可以通过contains()和compareDocumentPosition()来获取 12345678910111213function contains(ele1, ele2) &#123; return ele1.contains ? ele1 != ele2 &amp;&amp; ele1.contains(ele2) : !!(ele1.compareDocumentPosition(ele2) &amp; 16);&#125;//获得共有最近的父节点function getCommonRootNode(ele1, ele2) &#123; while (ele1) &#123; if (contains(ele1, ele2) || ele1 === ele2) &#123; return ele1; &#125; ele1 = ele1.parentNode; &#125; return null;&#125; 首先是DOMElement.contains(DOMNode)，作用于IE浏览器，用来确认DOMNode是否包含在另一个DOMElement中，是则返回true，注意，当DOMNode和DOMElement一致时，也是返回true，虽然不太合理 其次是NodeA.compareDocumentPosition(NodeB)，IE8及IE8以下不支持，比较两个节点，并返回描述它们在文档中位置的整数，需要注意这个方法的返回值： 如果满足P1在P2之前，而且P1包含P2，则返回结果就是4+16=20 load / DOMContentLoadedDOMContentLoaded事件：当初始HTML文档被完全加载和解析完成之后便触发，无需等待样式表、图像和子框架完成加载，低版本IE不支持，可以用onreadystatechange事件（判断if(document.readyState == &#39;complete&#39;)） load事件：在页面完全加载后触发，各浏览器都支持 具体可查看DOMContentLoaded与load的区别 relatedTargetrelatedTarget是一个事件属性，返回与事件的目标节点相关的节点 对于mouseover事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点 对于mouseout事件来说，该属性是离开目标时，鼠标指针进入的节点 对于其他类型的事件来说，这个属性没有用 成熟的手势库hammer.jszepto的touch模块","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"},{"name":"mobile","slug":"mobile","permalink":"//huzezhen.cn/tags/mobile/"}]},{"title":"自定义事件","date":"2017-04-02T10:26:00.000Z","path":"2017/04/02/custom-event/","text":"了解下自定义事件，主要是JavaScript中的事件触发器 前言在之前一篇关于 移动端触摸事件 的文章中，我们用到自定义事件来模拟click事件并阻止300ms后的原生click事件来解决点透问题 现在就讲下这个自定义事件，尤其是事件触发器：dispatchEvent(高级浏览器)、fireEvent(IE浏览器) 绑定绑定一个自定义事件，还是使用大家比较熟悉的addEventListener()和attachEvent() 既然提到了，就带大家回顾下这两个方法，可自行选择跳过 首先是addEventListener()方法，语法如下：1element.addEventListener(event, callback, useCapture) 参数event：绑定的事件名称参数callback：触发的回调函数，事件对象会作为第一个参数传入函数参数useCapture：布尔值，表示指定事件是在捕获（true）或冒泡（false）阶段执行，默认值是false（事件冒泡和捕获的执行顺序） 简单例子：1234var dom = document.getElementById('test');dom.addEventListener('click', function()&#123; console.log('click success!');&#125;, false) 需要注意的是IE8及IE8以下不支持addEventListener这个方法，它们绑定事件使用的是attachEvent() 1elemetn.attachEvent(event, callback) 参数event：绑定的事件名称，但是注意要加on，例如：onclick参数callback：触发的回调函数，事件对象会作为第一个参数传入函数 简单例子：1234var dom = document.getElementById(\"test\");dom.attachEvent('click', function()&#123; console.log('click success!');&#125;) 生成与触发我们先看一个例子，这例子就是一个自定义事件的触发器： 123456789101112var fireEvent = function(element,event) &#123; if (document.createEventObject) &#123; // IE浏览器支持fireEvent方法 var evt = document.createEventObject(); return element.fireEvent('on'+ event, evt) &#125; else &#123; // 其他标准浏览器使用dispatchEvent方法 var evt = document.createEvent('HTMLEvents'); evt.initEvent(event, true, true); return !element.dispatchEvent(evt); &#125; &#125;; 这里注意两个方面，一个是event对象实例的创建，一个是事件的触发 主要分为高级浏览器与IE浏览器两种情况： 在高级浏览器下： 先调用document对象的createEvent方法得到一个event对象实例 再执行这个对象实例的initEvent方法初始化，这方法接收三个参数：事件类型，是否冒泡，是否阻止浏览器的默认行为 初始化之后可以给这个对象实例加属性并定义值，这些属性的值能在触发之后的回调函数的事件对象取到 调用该DOM元素的dispatchEvent方法，参数是上面生成的对象实例，这样就触发了 在IE浏览器下： 调用doucment对象的createEventObject方法得到一个event对象实例 可以这个对象实例加属性并定义值，这些属性的值能在触发之后的回调函数的事件对象取到 调用该DOM元素的fireEvent方法，第一个参数是事件类型(绑定时事件没有on开头的话，这里记得前缀加上on)，第二个参数是上面得到的event对象实例 总结document.creatEventObject()是IE创建event对象实例的方法，和document.creatEvent( ‘HTMLEvents’ )在非IE主流浏览器下的作用相同 fireEvent是IE下的事件触发器，与dispatchEvent在非IE主流浏览器下作用相同","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"}]},{"title":"探索移动端事件","date":"2017-03-25T06:56:00.000Z","path":"2017/03/25/mobile-events/","text":"探索移动端的几个触摸事件 前言本文主要记录移动端几个touch类事件：touchstart、touchmove、touchend、touchcancel 以及事件对象event的几个主要属性：changedTouches、targetTouches、touches 记录的主要目的，首先是为了增加自己对移动端事件的了解，主要也是为了防止自己以后再做出将touchmove讲成touchover的蠢事，切记木有touchover这样的玩意！ touch类事件touchstart：当手指触摸到屏幕时会触发touchmove：当手指在屏幕上移动时触发touchend：当手指离开屏幕时触发touchcancel：可由系统自行触发，比如手指触摸屏幕的时候，突然alert了一下，或者系统中其他打断了touch行为，则可以触发该事件 事件触发顺序：touchstart &gt; touchmove &gt; touchend &gt; click 事件对象的主要属性这里重点了解下事件对象TouchEvent的三个重要属性： changedTouches：记录着触发该次事件的信息，一般length为1targetTouches：保存了当前所触碰屏幕的手指信息,记录的是当前DOM节点上全部的触摸对象的信息touches：保存了当前所有触碰屏幕的手指信息,记录的是屏幕上全部的触摸对象的信息 借助下面的场景帮忙理解：有两个div，分别为A和B，B绑定了touchstart事件，然后依次执行以下操作： 先放一根手指到B上面，触发touchstart事件，这时候三个属性都是一样的，包含这次触摸的Touch对象信息 在上步操作的前提下，再分别放一根手指到A和B上，又会触发B的touchstart事件，这时候changedTouches只会包含后来两次触摸的Touch对象信息，因为上步操作的手指不变，targetTouches记录的则是B上面两根手指触摸的Touch对象信息， touches则是屏幕上所有的触摸对象的信息，这里是指这三根手指触摸的Touch对象信息 如果使用jQuery，需要这样取这三个原生的触摸对象：e.originalEvent.changedTouches、e.originalEvent.targetTouches、e.originalEvent.touches 三个属性都是TouchList类型，每个属性都存储相关的Touch对象（一些触控位置、目标元素的信息） Touch对象的主要属性主要了解下Touch对象中有什么主要属性 clientX / clientY：触摸点相对浏览器窗口的位置pageX / pageY：触摸点相对于页面的位置screenX / screenY：触摸点相对于屏幕的位置identifier：Touch对象的IDtarget：记录当前的DOM元素 注意点第一个需要注意的地方，TouchEvent事件对象中的touches、targetTouches只存储接触屏幕的触点信息，所以在触发touchend事件时（即此刻手指已离开屏幕），这两个属性是空的，所以要获取触点最后离开的状态要使用changedTouches 第二个需要注意的地方，touchstart、touchmove、touchend、touchcancel、click的事件对象的target属性永远是触控事件最先发生的那个元素，借助下面的场景帮忙理解：大的元素A，小的元素B，我们从元素A滑动到元素B上然后松开手指，这时候是触发A元素的touchend事件，因为它是最先发生的元素 那如果我们想正确触发元素B的touchend事件的话，可借助document.elementFromPoint得到顶层的元素再来触发 1document.elementFromPoint(clientX, clientY) // 传入坐标值，可以得到包含该坐标点的最顶层的元素 扩展既然讲到了移动端的触摸事件，顺带提下它的click事件，大家都知道在移动端上click事件会有300ms的延迟，原因是因为在移动端浏览器上双击可以放大网页，浏览器为了区分是双击缩放还是点击事件，就设置了300ms的间隔时间，如果在300ms内有两次点击则认为是双击缩放 不过现在移动端网页基本会设置viewport来禁止用户缩放，但是部分低版本安卓、微信和QQ内置的webview还是会存在300ms延迟的问题1&lt;meta name=\"viewport\" content=\"width=device-width,user-scalable=no,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0&gt; 那怎么解决呢？有人就会想，用touchstart事件来替代click，这样会带来一些问题，首先例如长按也会被认为是一次点击，而且会带来另一个经典的问题：点透 那什么是点透呢，看以下场景：场景：元素上有个遮罩层，点击遮罩层时让遮罩层消失问题：点击遮罩层，根据上文我们用touchstart事件来绑定遮罩层，点击之后遮罩层消失，但是遮罩层下的元素300ms后触发click事件原因：touchstart事件发生后遮罩层消失后，浏览器会在300ms后找到当前最上层的元素触发click事件 为了解决这些问题，fastclick.js就出现了，大致原理：在检测到touchend事件时通过DOM自定义事件立即模拟一个click事件，再把300ms后的原生click事件阻止掉 关于DOM自定义事件再开篇详解 已更新，点击查看","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"},{"name":"mobile","slug":"mobile","permalink":"//huzezhen.cn/tags/mobile/"}]},{"title":"JavaScript 模块规范","date":"2017-02-23T12:30:00.000Z","path":"2017/02/23/javascript-module-Specification/","text":"关于JavaScript模块化编程规范一些总结 包括：CommonJS、AMD、CMD、UMD、ES6 前言随着web page进化到web application，浏览器端需要处理的逻辑越来越复杂，需要展现的样式和动画等效果越来越多，对工程的要求也越来越高，模块化的需求也应运而生 使用模块化有以下好处： 组件的复用，降低开发成本和维护成本 组件单独开发，方便分工合作 模块化遵循标准，方便自动化依赖管理，代码优化，部署 而模块与模块之间要相互依赖是需要编写代码时遵循一定的模块规范，现存有以下几种规范 CommonJS偏向于服务器端的规范，例如Node.js就是遵循这个规范 加载模块采取的同步方式（区别于AMD与CMD），是因为服务端模块放在本地硬盘上，加载很快 CommonJS的一个模块就是一个脚本文件，每个模块都是单独的作用域，即在一个文件定义的变量都是私有的，其他文件不可见 使用require方法来加载模块，第一次加载该脚本时就会执行整个脚本，然后在内存中生成一个对象，然后下次再调用require方法时，不会再执行该模块，而是从缓存中取值 123456&#123; id: '...', // 模块名字 exports: &#123; ... &#125;, // exports对象，模块导出的接口，别人从这里取值 loaded: true, // 表示模块是否加载完成 ...&#125; 简单的例子： 12345678// math.jsexports.add = function(a, b) &#123; return a + b;&#125;// other.jsvar math = require('math');math.add(1, 2); // 3 因为CommonJS规范采取的是同步的方式来加载模块，所以在浏览器端不适合（浏览器端从服务器端加载模块容易受带宽等影响），所以在浏览器端出现了一个AMD规范 AMDAMD(Asynchronous Module Definition)，即异步模块定义，采用异步方式加载模块，典型代表：RequireJS AMD也采用require方法加载模块，与CommonJS不同的是，它需要两个参数 1require([module], callback); 第一个参数[module]指想要加载的模块，是一个数组，即可以加载多个模块第二个参数为加载模块完成后立即执行的回调函数，该回调函数的参数与前面的模块数组一一对应 简单的例子： 123require([math], function(math) &#123; math.add(1, 2);&#125; 每个模块的编写，都要遵循AMD模块规范，即每个模块都要用define()函数来定义，具体如下 1define(id?, dependencies?, factory); 第一个参数id，可选，表示模块的名字，不填则默认该脚本的名字第二个参数dependencies，可选，表示依赖的模块，不填则默认[‘require’, ‘exports’, ‘module’]，具体依第三个参数（工厂方法的参数来定）第三个参数是模块的工厂函数，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值 简单的例子： 123456789// math.js，不依赖其他模块，返回一个对象define(function()&#123; var add = function(x, y) &#123; return x + y; &#125; return &#123; add: add &#125;&#125;) 1234// 调用math.js模块require([math], function(math) &#123; math.add(1, 2); //3&#125;) 可见，AMD模块规范是在一开始require的时候就加载了所有所需的模块，属于依赖前置，这就区别于接下来要说的CMD模块规范，CMD规范是依赖就近 CMDCMD规范是SeaJS在推广过程中对模块定义的规范化产出的，它推崇依赖就近，延迟执行 简单的例子： 12345678910define(function (requie, exports, module) &#123; // 依赖可以就近书写 var a = require('./a'); a.test(); // 软依赖，所谓软依赖就是满足一定条件才加载某模块 if (status) &#123; var b = require('./b'); b.test(); &#125;&#125;); 跟AMD最大的区别就是：AMD是依赖前置，CMD是依赖就近 跟AMD的相同点：都是用difine和require，都会预加载依赖的js文件（但是调用和声明依赖的地方不同） 需要注意的是： AMD也可以像CMD一样在代码中使用require来加载模块，但是这样的话这个模块就不会预先加载，而是在用到的时候同步加载（所以也不推荐这样写） CMD的define也可以带三个参数，但是带id和dependencies参数的define用法不属于CMD规范，而属于Modules/Transport规范 UMD通用模块规范，例如：你写了个小工具，希望他支持AMD又支持CommonJS，就可以使用UMD 人们希望一种规范来支持AMD和CommonJS规范，UMD应运而生，同时支持AMD和CommonJS规范，也支持古老的全局模块规范 12345678910111213141516171819202122(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery', 'underscore'], factory); &#125; else if (typeof exports === 'object') &#123; // Node, CommonJS-like module.exports = factory(require('jquery'), require('underscore')); &#125; else &#123; // Browser globals (root is window) root.returnExports = factory(root.jQuery, root._); &#125;&#125;(this, function ($, _) &#123; //方法 function a()&#123;&#125;; //私有方法，因为下面没有在return中暴露 function b()&#123;&#125;; //在return中暴露的方法 function c()&#123;&#125;; //在return中暴露的方法 //暴露多个方法 return &#123; b: b, c: c &#125;&#125;)); UMD规范就像是一个语法糖，应用UMD规范的JS就是一个IIFE（立即执行函数），参数一是执行的环境，参数二是模块的定义体 从代码也可以看出，优先判断是否支持AMD，再判断CommonJS，两者都不支持则认为是浏览器环境（window） ES6的模块化ES6发布的module并没有直接采用CommonJS，甚至连require都没有采用 它采用import、export实现模块的输入输出，import来导入其他模块提供的功能，export来规定模块的对外接口 有关export(导出)的几个简单例子 123456789101112131415161718192021222324252627/* * 导出变量 - a.js */ export var a = 1;export var b = 2;// 或者var a = 1;var b = 2;export &#123;a, b&#125;/* * 导出函数 */ export function foo()&#123;&#125;export function bar()&#123;&#125;// 或者function foo()&#123;&#125;function bar()&#123;&#125;export &#123;foo, bar as bar2&#125; // as是来给导出的变量名重命名/* * 导出类 */ export default class &#123;&#125; // 关于export default，下面会讲到 有关import(导入)的几个简单例子 1234567891011/* * 导入变量a和b */import &#123;a, b&#125; from 'a' // 上面export例子中的a.js，后缀可省略console.log(a + b); // 3/* * 导入变量a和b，并将a重命名为c */import &#123;a as c, b&#125; from 'a' // 利用as来重命名，在import一样有效 利用 * 关键字来整体加载 123456789// b.jsvar a = 1;var b = 2;export &#123;a, b&#125;// main.jsimport * as num from 'b' // 使用*号来导入整体，并用as来重命名console.log(num.a);console.log(num.b); 关于export default 本质上，export default输出的是一个叫做default的变量或方法，输入这个default变量时不需要花括号 123456789101112// 导出函数 - c.jsexport default function() &#123;&#125;// 等效于：function a() &#123;&#125;;export &#123;a as default&#125;;// 导入时可以这样import a from 'c';// 等效于，或者说就是下面这种写法的简写，是同一个意思import &#123;default as a&#125; from 'c'; 所以，当我们看到import哪个变量时没有花括号（没有*号），我们应该在脑海里能还原它带花括号时应该是怎么样的 1import $,&#123;each,map&#125; from 'jquery'; // 这里的$，其实就是&#123;default as $&#125;的简写 扩展关于node.js的module.exports和exportsNode中没搞明白require和import，你会被坑的很惨","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"}]},{"title":"关于Javascript的严格模式","date":"2017-01-23T06:26:00.000Z","path":"2017/01/23/strict-mode/","text":"ECMAScript 5新增了一种新的运行模式：严格模式 1. 前言本文主要为了解决三个问题：为什么要用严格模式、如何进入严格模式、严格模式有哪些规则？ 2. 使用严格模式有什么作用消除JavaScript语法的一些不合理、不严谨的地方，减少怪异行为（当确定的问题发生时抛出相应错误）消除代码运行中的一些不安全的地方，确保代码运行的安全提高编译器效率，增加运行速度 3. 如何进入严格模式首先，进入的严格模式的标志是：&#39;use strict&#39;; 3.1 针对整个脚本在顶部写上: &#39;use strict&#39;;，这段脚本就在严格模式中执行 12345678910&lt;script&gt;'use strict';// 这样就进入严格模式 console.log('严格模式');&lt;/script&gt;&lt;script&gt;// 这样是正常模式console.log('正常模式')&lt;/script&gt; 3.2 针对单个函数在函数体内第一行写上：&#39;use strict&#39;;，这个函数就启用严格模式执行 12345678function fn1() &#123; 'use strict'; console.log('严格模式');&#125;function fn2() &#123; console.log('正常模式');&#125; 3.3 其他注意点支持严格模式的浏览器有：IE10+、Firefox4+、safari12+、opera12+、chrome不支持严格模式的浏览器会将&#39;use strict&#39;;当作普通字符串语句执行 4. 严格模式的规则4.1 变量方面的规则 全局变量需显式声明，不能意外创建 123'use strict';a = 1; // 报错，在正常模式下会当成全局变量console.log(a); 不能对变量调用delete操作符根本原因是var、let、const声明的变量默认是不可配置的，即configurable的值是false 123'use strict';var a = 1;delete a; // 报错，在正常模式下会返回false而不会报错，也是不会删除成功 严格模式下新增一些保留字不可作为变量名保留字：implements, interface, let, package, private, protected, public, static, yield 4.2 对象方面的规则 不能对只读属性赋值 12345678var person = &#123; name: 'lily'&#125;Object.defineProperty(person, 'name', &#123; writable: false // 设置为只读属性&#125;)person.name = 'lucy'; // 会报错，正常模式下不会报错，但也赋值不成功console.log(person.name); // 正常模式下输出'lily' 不能对不可配置的属性进行delete操作 12345678var store = &#123; book: '哈利波特'&#125;Object.defineProperty(store, 'book', &#123; configurable: false // 设置为不可配置属性&#125;)delete store.book; // 会报错，正常模式不会报错，但也删除不了console.log(store.book); // 正常模式会输出'哈利波特' 不能对一个使用getter方法读取的属性进行赋值 12345 var obj = &#123;get p() &#123;return 1;&#125; // getter方法 &#125; obj.p = 2; // 报错，正常模式不会报错，但也赋值不了 console.log(obj.p); // 正常模式会输出2 不能对禁止扩展的对象添加新属性使用Object.preventExtensions(obj)方法来让obj无法拓展 123var obj = &#123;&#125;;Object.preventExtensions(obj); // 这样obj就无法拓展obj.a = 1; // 报错，正常模式则不会报错，但是也拓展属性不成功，obj仍是空对象 4.3 函数方面的规则 函数如果有多个参数，参数名不能重名 1234 function test(num, num)&#123; // 会报错console.log(num); // 正常模式会输出2 &#125; test(1, 2); 修改形参不会反映到arguments中，即arguments不追踪参数的变化 123456function fn(value) &#123; value = '形参的数据被修改'; console.log(arguments[0]); // arguments的值不会因为形参被修改而修改，所以arguments[0]还是'形参'，正常模式下会输出'形参的数据被修改' console.log(value); // '形参的数据被修改'&#125;fn('形参'); 不允许使用arguments.callee和函数的caller函数的caller：在一个函数调用另一个函数时，被调用函数会自动生成一个caller属性，指向调用它的函数对象arguments.callee：当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用 12345678910function fn() &#123; var caller = testCaller.caller; // 会报错 var callee = arguments.callee; // 会报错 alert(caller); // 正常模式会弹出 function aCaller() &#123; fn(); &#125; alert(callee); // 正常模式会弹出自身函数的实现代码&#125;function aCaller() &#123; fn(); &#125; aCaller() 4.4 其他规则 创设eval作用域 123var x = 2;console.log(eval('var x = 3;x')); // 3，因为在严格模式下，eval语句本身就是一个作用域console.log(x); // 2，正常模式会输出3，因为值经过eval语句的执行已经被改变为3 禁止this关键字指向全局对象 1234function other() &#123; console.log(this.value); // 报错，this不会指向全局对象，报错：Cannot read property 'value' of undefined&#125; other(); 不允许使用八进制字面量 12var other = 010; // 报错：Octal literals are not allowed in strict modeconsole.log(other); // 正常模式下会输出8 不允许使用with语句 不允许使用eval和arguments作为标识符，不能对他们进行赋值","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"}]},{"title":"HTML5新特性与技巧","date":"2016-10-10T13:04:08.000Z","path":"2016/10/10/html5-new-feature/","text":"记录HTML5的一些新的特性与技巧 新的文档类型声明1&lt;!DOCTYPE html&gt; 字符集HTML5使用UTF-8编码 去除link和script标签里的type属性script和link里不需要写type figure和figcaption标签的组合语义化地将图片与注释联系起来 123456&lt;figure&gt; &lt;img src=\"xxx.jpg\" /&gt; &lt;figcaption&gt; &lt;p&gt;这是一幅图片的描述&lt;/p&gt; &lt;/figcaption&gt;&lt;/figure&gt; 语义化了header和footer标签123&lt;header&gt;...&lt;/header&gt; 123&lt;footer&gt;...&lt;/footer&gt; 新的small标签HTML5里small标签将旁注呈现为小型文本，负责声明、注意事项、法律限制或版本声明的特征通常都是小型文本。在HTML4或XHTML里已经定义过small，不过对它的使用却没有一个完整的说明。在HTML里，它主要用于网页下方的版本声明，邮箱等小型文本。 hgroup标签(HTML5.1中已废除)主要表明标题的集合，用处不大，如果想表明主标题与副标题，可如下： 使用标点符号 1&lt;h1&gt;前端博文:HTML5新特性与技巧&lt;/h1&gt; 使用span标签 123&lt;h1&gt;前端博文 &lt;span&gt;HTML5新特性与技巧&lt;/span&gt;&lt;/h1&gt; 使用header标签 1234&lt;header&gt; &lt;h1&gt;前端博文&lt;/h1&gt; &lt;p&gt;HTML5新特性与技巧&lt;/p&gt;&lt;/header&gt; mark标签标签内的字符会高亮显示 1&lt;mark&gt;文字高亮&lt;/mark&gt; contenteditable属性让一个div元素变得可编辑，可在div中加上contenteditable属性，如： 1&lt;div contenteditable=\"true\"&gt;&lt;/div&gt; 但是需要注意，这样的话富文本也可以输入进去，如果想限制只能输入纯文本的话，可以这样： 1&lt;div contenteditable=\"plaintext-only\"&gt;&lt;/div&gt; placeholder属性这个属性是占位符的意思，不用像以前用JS来实现占位符，可直接使用该属性（支持HTML5的浏览器）placeholder属性适用于以下的input类型：text，search，url，telephone，email以及password 1&lt;input type=\"text\" placeholder=\"请输入数字\" &gt; 但是不支持HTML5的浏览器还是得用JS的方法去实现占位符，因此大多数网站都是用label标签来假装占位符，通过隐藏和显示来实现效果以便兼容大部分浏览器 required属性指明某一输入是否必需，有两种声明方式： 123&lt;input type=\"text\" name=\"input1\" required&gt;或&lt;input type=\"text\" name=\"input2\" required=\"required\"&gt; 主要在表单中用，声明了required的元素为空，提交时输入框会高亮提示 autofocus属性让元素（按钮、文本框等）自动获得焦点，而不用通过JS，如： 123&lt;input type=\"text\" autofocus&gt;或&lt;input type=\"text\" autofocus=\"autofocus\"&gt; pattern属性可在标签中通过这个属性来插入正则表达式，如： 1&lt;input type=\"text\" pattern=\"[A-Za-z]&#123;4,10&#125;\"&gt; 如果浏览器支持pattern属性，表单提交时会验证，不通过文本框会高亮提示 data属性自定义属性，以data前缀定义我们的自定义属性data-* HTML代码 1&lt;div id=\"myDiv\" data-custom-val=\"my value\"&gt;&lt;/div&gt; 获取属性值的方法 1234var divEl = document.getElementById(\"myDiv\");alert(divEl.dateset.customVal); /* 通过dateset对象读取，注意需要使用驼峰写法 */alert(divEl.getAttribute(\"data-custom-val\")); /* 通过getAttribute方法读取 */alert($(\"#myDiv\").data(\"customVal\")); /*通过jQuery的data方法读取，同样需要注意驼峰写法*/ 设置属性值的方法 1234var divEl = document.getElementById(\"myDiv\");divEl.dataset.customVal = \"the new value\"; /* 通过dateset对象设置，驼峰写法 */divEl.setAttribute(\"data-custom-val\",\"the new value\"); /* 通过setAttribute方法设置 */$(\"#myDiv\").data(\"customVal\",\"the new value\"); /* jQuery的data方法 */ CSS中也可以这样使用12345678&lt;style&gt; h1:hover:after&#123; content:attr(data-custom-val); /*注意这里*/ color:black; position:absolute; left:0; &#125;&lt;/style&gt; input文本框中type为email表单中的input设置type为email后，提交表单会判断是否邮件格式，不是则文本框高亮提示 input文本框的type为range创建滑块，如： 1&lt;input type=\"range\" min=\"0\" max=\"10\" step=\"1\" value=\"\"&gt; 可以使用css中的:before和:after来显示min和max的值，如： 12345678input[type=\"range\"]:before&#123; content:attr(min); padding-right:5px;&#125;input[type=\"range\"]:after&#123; content:attr(max); padding-left:5px;&#125; 两种本地存储方案：localStorage和sessionStoragelocalStorage： 持久化的本地存储，除非自己清除，否则不会过期sessionStorage: 会话级别的存储，同一个会话中的页面才能访问，且会话结束后数据也会销毁 后续准备写一篇文章详细探讨两者以及与cookies的区别对比 HTML5表单特性新增了一些新的表单元素 datalist、datetime、output、keygen、date、month、week、time、color、number、range、email、url 音视频标签HTML5支持mp3、wav、ogg格式的音频，使用audio标签 12345&lt;audio autoplay controls&gt; &lt;source src=\"file.ogg\"&gt; &lt;source src=\"file.mp3\"&gt; &lt;a href=\"file.mp3\"&gt;Download&lt;/a&gt;&lt;audio&gt; HTML5支持mp4、webm、ogg格式的视频，使用video标签 注意：不设置type类型是可以的，但是设置了的话浏览器就不用自己去寻找类型 12345&lt;video controls preload&gt; &lt;source src=\"file.ogg\" type=\"video/ogg; codecs='vorbis,theora'\" /&gt; &lt;source src=\"file.mp4\" type=\"video/mp4; codecs='avc1.42E01E, mp4a.40.2'\" /&gt; &lt;p&gt; Your browser is old. &lt;a href=\"file.mp4\"&gt; Download this video.&lt;/a&gt;&lt;/p&gt;&lt;/video&gt; preload属性决定是否在浏览器加载页面时预先加载视频资源controls属性决定是否视频上显示进度条（不同浏览器样式是不一样的） 检测属性支持例如检测浏览器是否支持pattern属性，可以这样： 1alert(\"pattern\" in document.createElement(\"input\")); /* boolean */ 标签的闭合与属性的引号HTML5不是XHTML，没有要求一定要引号和闭合元素，例如： 1&lt;p class=myClass id=myId&gt;这是一个没有闭合的p元素 不过为了可读性还是建议加上闭合 哪些不是HTML5，HTML5废弃哪些HTML4标签不是HTML5： 12345SVGCSS3GeolocationClient StroageWeb Sockets HTML5废弃的HTML4标签 frame、frameset、noframe、applet、big、center、basefont output标签定义不同类型的输出，显示计算的结果 12345&lt;form oninput=\"x.value=parseInt(a.value)+parseInt(b.value)\"&gt;0 &lt;input type=\"range\" id=\"a\" value=\"50\"&gt;100 +&lt;input type=\"number\" id=\"b\" value=\"50\"&gt; =&lt;output name=\"x\" for=\"a b\"&gt;&lt;/output&gt;&lt;/form&gt; 显示如下：","comments":true,"tags":[{"name":"HTML5","slug":"HTML5","permalink":"//huzezhen.cn/tags/HTML5/"},{"name":"新特性","slug":"新特性","permalink":"//huzezhen.cn/tags/新特性/"}]},{"title":"移动端上阻止页面滚动与恢复页面滚动","date":"2016-10-09T09:53:07.000Z","path":"2016/10/09/stop-scroll-and-recover/","text":"移动端开发时，如何在遮罩层出现的同时让背景失去上下滚动的能力？ 场景在一个HTML5页面上，弹出框弹出之后，显示遮罩层，背景其他按钮确实不能点，但在手机上测试，背景可以上下滑动 目标在弹出框出现时阻止页面滚动并在弹出框消失后恢复滚动 方案方案一上锁：1$(\"body\").css(\"position\",\"fixed\"); //这样的话，背景就固定了，但是页面会滚动到顶部 解锁：1$(\"body\").css(\"position\",\"relative\"); //这样就恢复滚动 方案二上锁：思路就是阻止touchmove事件的默认行为，在弹出框的时候阻止body的touchmove事件的默认行为解锁：在弹出框消失的时候恢复这个默认行为具体方案如下：123function bodyScroll(e)&#123; e.preventDefault();&#125; 原生写法，注意IE8以及IE8以下使用attachEvent()和detachEvent()12document.addEventListener(\"touchmove\",bodyScroll,false); /*上锁*/docume.removeEventListener(\"touchmove\",bodyScroll,false); /*解锁*/ jQuery写法12$(\"body\").on(\"touchmove\",bodyScroll); /*上锁*/$(\"body\").off(\"touchmove\",bodyScroll); /*解锁*/","comments":true,"tags":[{"name":"javascript","slug":"javascript","permalink":"//huzezhen.cn/tags/javascript/"},{"name":"wap","slug":"wap","permalink":"//huzezhen.cn/tags/wap/"}]}]